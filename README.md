# üèÜ Programa√ß√£o Competitiva:

![C++](https://img.shields.io/badge/C%2B%2B-00599C?style=for-the-badge&logo=c%2B%2B&logoColor=white)
![Status](https://img.shields.io/badge/Status-Em_Treinamento-green?style=for-the-badge)

Este reposit√≥rio √© o meu "local de treinamento" focado na **OBI (Olimp√≠ada Brasileira de Inform√°tica)** e no fortalecimento do meu racioc√≠nio l√≥gico para resolu√ß√£o de problemas. Aqui, aplico os conhecimentos do curso de inform√°tica do **NOIC** e pratico com problema e exerc√≠cios em plataformas como a **Neps Academy**.

## üéØ Objetivos:
- [ ] Conquistar medalha na **OBI 2026** (N√≠vel 1, modalidade de programa√ß√£o).
- [ ] Construir um portf√≥lio s√≥lido em programa√ß√£o competitiva com C++.
- [ ] Participar de outras **competi√ß√µes de programa√ß√£o.

---

## üìÇ Estrutura do Reposit√≥rio

O reposit√≥rio est√° organizado por temas e plataformas separadas, facilitando o entendimento dos estudos:

* `üìÇ Neps-Academy/`: Problemas e exerc√≠cios do Neps Academy, divididos por conte√∫do e n√≠vel.

---

## üöÄ Meu Roadmap de Estudos

### üåü PARTE 1: N√≠vel 1 da OBI (Ouro Estrat√©gico):
Foco: Dom√≠nio de implementa√ß√£o, l√≥gica b√°sica e algoritmos de busca. √â o necess√°rio para vencer na sua categoria atual.

üîπ Fase 1: Fundamentos de C++:
    * Come√ßando do Zero: Instala√ß√£o, cin, cout, vari√°veis e tipos de dados.
    * Estruturas Condicionais: if, else if, else e operadores l√≥gicos.
    * Loops: Repeti√ß√µes com while e for.
    * Vetores (Arrays): Armazenamento de sequ√™ncias de dados simples.
    * Matriz: Arrays bidimensionais (tabelas e mapas).
    * Fun√ß√µes: Modulariza√ß√£o de c√≥digo e passagem de par√¢metros.
    * Complexidade de Algoritmos: No√ß√£o de tempo de execu√ß√£o O(N), O(N^2), etc.

üîπ Fase 2: T√©cnicas e Matem√°tica Base:
    * Ordena√ß√£o: Uso da fun√ß√£o std::sort e algoritmos b√°sicos.
    * Somas de Prefixo: Pr√©-processamento de somas em intervalos O(1) por consulta.
    * Busca Bin√°ria: Encontrar valores em conjuntos ordenados e busca bin√°ria na resposta.
    * Primalidade, Divisores e Fatora√ß√£o: Matem√°tica b√°sica de n√∫meros primos e decomposi√ß√£o.
    * Crivo de Erat√≥stenes: M√©todo eficiente para encontrar todos os primos at√© N.

üîπ Fase 3: Introdu√ß√£o a Estruturas e Grafos:
    * Explorando a STL: Uso de vector, set, map, queue e stack.
    * Busca em Grafos (DFS e BFS): Travessia em redes e listas de adjac√™ncia.
    * DFS em Grid: Aplica√ß√£o de buscas em matrizes (mapas de caracteres).
    * Algoritmo Guloso: Problemas que pedem a melhor escolha local imediata.
    * Combinat√≥ria: Princ√≠pio Fundamental da Contagem, permuta√ß√µes e combina√ß√µes b√°sicas.

### üöÄ PARTE 2: N√≠vel 2 da OBI (Aprofundamento)
Foco: Algoritmos cl√°ssicos de grafos, otimiza√ß√£o e estruturas de dados din√¢micas.

üîπ Fase 4: Grafos Avan√ßados e Caminhos:
    * Menor Caminho (Dijkstra): Encontrar a rota mais curta em grafos com pesos.
    * Union-Find e Union-Find++: Gerenciamento de conjuntos disjuntos e conectividade.
    * √Årvore Geradora M√≠nima (MST): Algoritmos de Kruskal ou Prim para conectar pontos com custo m√≠nimo.
    * Ordena√ß√£o Topol√≥gica: Ordenar tarefas com depend√™ncias entre si.
    * Two Pointers: T√©cnica de dois ponteiros para otimizar buscas em vetores ordenados.

üîπ Fase 5: Estruturas de Dados e PD Inicial:
    * Binary Indexed Tree (BIT): Atualiza√ß√£o e consulta de somas em intervalos de forma eficiente.
    * Introdu√ß√£o √† Programa√ß√£o Din√¢mica (DP): Conceito de memoriza√ß√£o e subproblemas.
    * Problema da Mochila (Knapsack): Cl√°ssico de otimiza√ß√£o de recursos.
    * Soma M√°xima em Intervalo: Algoritmo de Kadane.
    * Ponteiros: Entendimento de endere√ßos de mem√≥ria (base para estruturas manuais).

üîπ Fase 6: Matem√°tica e Miscel√¢nea T√©cnica:
    * Exponencia√ß√£o R√°pida: Calcular A^B (mod M) em tempo logar√≠tmico.
    * Princ√≠pio da Inclus√£o e Exclus√£o: Contagem avan√ßada de conjuntos.
    * Bitmask: Uso de inteiros para representar estados de conjuntos.
    * Compress√£o de Coordenadas: Mapear valores grandes para um intervalo pequeno.
    * Guia de Problemas Interativos: Como lidar com problemas que "respondem" ao seu c√≥digo.

### üî• PARTE 3: N√≠vel S√™nior (Elite Competitiva):
Foco: Estruturas de dados complexas, geometria e t√©cnicas avan√ßadas de DP e √Årvores.

üîπ Fase 7: √Årvores e Segmenta√ß√£o:
    * Introdu√ß√£o a √Årvores: Propriedades de grafos sem ciclos.
    * Di√¢metros e Centros: Encontrar a maior dist√¢ncia dentro de uma √°rvore.
    * Binary Lifting e LCA: Menor Ancestral Comum e pulos logar√≠tmicos.
    * Segment Tree (√Årvore de Segmentos): Consultas e atualiza√ß√µes gen√©ricas em intervalos.
    * Segment Tree com Lazy Propagation: Atualiza√ß√µes de intervalos inteiros em O(log N).

üîπ Fase 8: Din√¢mica e Estruturas de Elite:
    * DP em Intervalo e DP em √Årvore: Programa√ß√£o din√¢mica em estruturas n√£o lineares.
    * Busca Bin√°ria em Estruturas: Unir busca bin√°ria com BIT ou SegTree.
    * Sparse Table: Consultas de RMQ (Range Minimum Query) em tempo constante O(1).
    * Min/Max Queue: Filas que permitem consultar o maior/menor elemento em O(1).
    * Merge Sort Tree: √Årvore de segmentos onde cada n√≥ √© um vetor ordenado.

üîπ Fase 9: Geometria, Grafos Finais e Strings:
    * Geometria Computacional: Pontos, vetores, produtos escalar/vetorial e Convex Hull (Fecho Convexo).
    * BFS 0/1 e Dijkstra com V√©rtices Auxiliares: Truques de modelagem de grafos.
    * Caminho e Ciclo Euleriano: Passar por todas as arestas de um grafo exatamente uma vez.
    * Maior Subsequ√™ncia Crescente (LIS): Problema cl√°ssico de DP com otimiza√ß√£o.
    * Line Sweep: T√©cnica de "varredura" para resolver problemas geom√©tricos e de intervalos.
    * Congru√™ncias: Aprofundamento em aritm√©tica modular.